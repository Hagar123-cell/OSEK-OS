
#include "riscv_context_switching.h"

.extern currentTCB
.extern nextTCB

.global RISCV_CONTEXT_SWITCH


# All general purpose registers are pushed into the stack except x0 , x2 ,x3 and x4 :
# x0 since it's value is 0 and it can't be changed.
# x2 (sp) since it's value saved in TCB.
# x3 (gp) since it's used to point to the area where global variable are located so it can be accessed with small offset from gp
# and it's value is intialized early in the program and never change.
# x4 (tp) since it's used in multithreading and we are porting on single core RISC-V. 

RISCV_CONTEXT_SWITCH:

#*******************************************************************************
#                                 Save Context                                 
#*******************************************************************************
    
    addi sp, sp, -portCONTEXT_SIZE     
    
    STORE_REG x1,  X1_STACK_OFFSET  ( sp )      # ra
    STORE_REG x5,  X5_STACK_OFFSET  ( sp )      # t0
    STORE_REG x6,  X6_STACK_OFFSET  ( sp )      # t1
    STORE_REG x7,  X7_STACK_OFFSET  ( sp )      # t2
    STORE_REG x8,  X8_STACK_OFFSET  ( sp )      # s0
    STORE_REG x9,  X9_STACK_OFFSET  ( sp )      # s1
    STORE_REG x10, X10_STACK_OFFSET ( sp )      # a0
    STORE_REG x11, X11_STACK_OFFSET ( sp )      # a1
    STORE_REG x12, X12_STACK_OFFSET ( sp )      # a2
    STORE_REG x13, X13_STACK_OFFSET ( sp )      # a3
    STORE_REG x14, X14_STACK_OFFSET ( sp )      # a4
    STORE_REG x15, X15_STACK_OFFSET ( sp )      # a5
    STORE_REG x16, X16_STACK_OFFSET ( sp )      # a6
    STORE_REG x17, X17_STACK_OFFSET ( sp )      # a7
    STORE_REG x18, X18_STACK_OFFSET ( sp )      # s2
    STORE_REG x19, X19_STACK_OFFSET ( sp )      # s3
    STORE_REG x20, X20_STACK_OFFSET ( sp )      # s4
    STORE_REG x21, X21_STACK_OFFSET ( sp )      # s5
    STORE_REG x22, X22_STACK_OFFSET ( sp )      # s6
    STORE_REG x23, X23_STACK_OFFSET ( sp )      # s7
    STORE_REG x24, X24_STACK_OFFSET ( sp )      # s8
    STORE_REG x25, X25_STACK_OFFSET ( sp )      # s9
    STORE_REG x26, X26_STACK_OFFSET ( sp )      # s10
    STORE_REG x27, X27_STACK_OFFSET ( sp )      # s11
    STORE_REG x28, X28_STACK_OFFSET ( sp )      # t3
    STORE_REG x29, X29_STACK_OFFSET ( sp )      # t4
    STORE_REG x30, X30_STACK_OFFSET ( sp )      # t5
    STORE_REG x31, X31_STACK_OFFSET ( sp )      # t6

    csrr t0, mstatus                            # copy mstatus into t0
    STORE_REG t0, MSTATUS_STACK_OFFSET ( sp )   # push mstatus register into stack to save the Machine previous interrupt enable bit (MPIE bit) in the mstatus.


    LOAD_REG  t0, currentTCB            # load value of currectTCB (address of the current TCB)
    STORE_REG  sp, 0( t0 )              # save the SP value into current TCB.             

    csrr a1, mepc            # mepc rigister contains the return address from exeption.
    addi a1, a1, 4           # Exeptions are Synchronous (generated by instruction),it's return address points to the instruction that generated the Excepion. 
                             # adding 4 updates the return address to point to the instruction after the instruction that generated the exeption.
    STORE_REG a1, PC_STACK_OFFSET  ( sp )       # store the new value of mepc into the stack    


#*******************************************************************************
#                             Restore Context                                 
#*******************************************************************************

    # next three lines equivalent to (currentTCB=nextTCB;) in c 
    la t0,currentTCB             # t0 contains address of currectTCB i.e. &currectTCB  
    LOAD_REG  t1, nextTCB        # t1 contains the value of nextTCB i.e. nextTCB (address of the next TCB )  
    STORE_REG t1,0(t0)           # store nextTCB into &currectTCB  
              
    LOAD_REG  sp, 0( t1 )        # load sp from nextTCB
    
    LOAD_REG t0,  PC_STACK_OFFSET ( sp )
    csrw mepc, t0
 
    LOAD_REG  t0, MSTATUS_STACK_OFFSET ( sp )
    csrw mstatus, t0                        

    LOAD_REG x1,  X1_STACK_OFFSET  ( sp )
    LOAD_REG x5,  X5_STACK_OFFSET  ( sp )
    LOAD_REG x6,  X6_STACK_OFFSET  ( sp )
    LOAD_REG x7,  X7_STACK_OFFSET  ( sp )
    LOAD_REG x8,  X8_STACK_OFFSET  ( sp )
    LOAD_REG x9,  X9_STACK_OFFSET  ( sp )
    LOAD_REG x10, X10_STACK_OFFSET ( sp )
    LOAD_REG x11, X11_STACK_OFFSET ( sp )
    LOAD_REG x12, X12_STACK_OFFSET ( sp )
    LOAD_REG x13, X13_STACK_OFFSET ( sp )
    LOAD_REG x14, X14_STACK_OFFSET ( sp )
    LOAD_REG x15, X15_STACK_OFFSET ( sp )
    LOAD_REG x16, X16_STACK_OFFSET ( sp )
    LOAD_REG x17, X17_STACK_OFFSET ( sp )
    LOAD_REG x18, X18_STACK_OFFSET ( sp )
    LOAD_REG x19, X19_STACK_OFFSET ( sp )
    LOAD_REG x20, X20_STACK_OFFSET ( sp )
    LOAD_REG x21, X21_STACK_OFFSET ( sp )
    LOAD_REG x22, X22_STACK_OFFSET ( sp )
    LOAD_REG x23, X23_STACK_OFFSET ( sp )
    LOAD_REG x24, X24_STACK_OFFSET ( sp )
    LOAD_REG x25, X25_STACK_OFFSET ( sp )
    LOAD_REG x26, X26_STACK_OFFSET ( sp )
    LOAD_REG x27, X27_STACK_OFFSET ( sp )
    LOAD_REG x28, X28_STACK_OFFSET ( sp )
    LOAD_REG x29, X29_STACK_OFFSET ( sp )
    LOAD_REG x30, X30_STACK_OFFSET ( sp )
    LOAD_REG x31, X31_STACK_OFFSET ( sp )
    
    addi sp, sp, portCONTEXT_SIZE

    
    ret

