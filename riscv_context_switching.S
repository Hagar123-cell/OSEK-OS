
#include "riscv_context_switching.h"

.extern currentTCBPtr
.extern nextTCBPtr

.global RISCV_CONTEXT_SWITCH
.global initialiseStack
.global restoreContext

# All general purpose registers are pushed into the stack except x0 , x2 ,x3 and x4 :
# x0 since it's value is 0 and it can't be changed.
# x2 (sp) since it's value saved in TCB.
# x3 (gp) since it's used to point to the area where global variable are located so it can be accessed with small offset from gp
# and it's value is intialized early in the program and never change.
# x4 (tp) since it's used in multithreading and we are porting on single core RISC-V. 

RISCV_CONTEXT_SWITCH:

#*******************************************************************************
#                                 Save Context                                 
#*******************************************************************************
    
    addi sp, sp, -CONTEXT_SIZE     
    
    STORE_REG x1,  X1_STACK_OFFSET  ( sp )      # ra
    STORE_REG x5,  X5_STACK_OFFSET  ( sp )      # t0
    STORE_REG x6,  X6_STACK_OFFSET  ( sp )      # t1
    STORE_REG x7,  X7_STACK_OFFSET  ( sp )      # t2
    STORE_REG x8,  X8_STACK_OFFSET  ( sp )      # s0
    STORE_REG x9,  X9_STACK_OFFSET  ( sp )      # s1
    STORE_REG x10, X10_STACK_OFFSET ( sp )      # a0
    STORE_REG x11, X11_STACK_OFFSET ( sp )      # a1
    STORE_REG x12, X12_STACK_OFFSET ( sp )      # a2
    STORE_REG x13, X13_STACK_OFFSET ( sp )      # a3
    STORE_REG x14, X14_STACK_OFFSET ( sp )      # a4
    STORE_REG x15, X15_STACK_OFFSET ( sp )      # a5
    STORE_REG x16, X16_STACK_OFFSET ( sp )      # a6
    STORE_REG x17, X17_STACK_OFFSET ( sp )      # a7
    STORE_REG x18, X18_STACK_OFFSET ( sp )      # s2
    STORE_REG x19, X19_STACK_OFFSET ( sp )      # s3
    STORE_REG x20, X20_STACK_OFFSET ( sp )      # s4
    STORE_REG x21, X21_STACK_OFFSET ( sp )      # s5
    STORE_REG x22, X22_STACK_OFFSET ( sp )      # s6
    STORE_REG x23, X23_STACK_OFFSET ( sp )      # s7
    STORE_REG x24, X24_STACK_OFFSET ( sp )      # s8
    STORE_REG x25, X25_STACK_OFFSET ( sp )      # s9
    STORE_REG x26, X26_STACK_OFFSET ( sp )      # s10
    STORE_REG x27, X27_STACK_OFFSET ( sp )      # s11
    STORE_REG x28, X28_STACK_OFFSET ( sp )      # t3
    STORE_REG x29, X29_STACK_OFFSET ( sp )      # t4
    STORE_REG x30, X30_STACK_OFFSET ( sp )      # t5
    STORE_REG x31, X31_STACK_OFFSET ( sp )      # t6

    csrr t0, mstatus                            # copy mstatus into t0
    STORE_REG t0, MSTATUS_STACK_OFFSET ( sp )   # push mstatus register into stack to save the Machine previous interrupt enable bit (MPIE bit) in the mstatus.


    LOAD_REG  t0, currentTCBPtr            # load value of currectTCBPtr (address of the current TCB)
    STORE_REG  sp, 0( t0 )              # save the SP value into current TCB.             

    csrr a1, mepc            # mepc rigister contains the return address from exeption.
    addi a1, a1, 4           # Exeptions are Synchronous (generated by instruction),it's return address points to the instruction that generated the Excepion. 
                             # adding 4 updates the return address to point to the instruction after the instruction that generated the exeption.
    STORE_REG a1, PC_STACK_OFFSET  ( sp )       # store the new value of mepc into the stack    


#*******************************************************************************
#                             Restore Context                                 
#*******************************************************************************
 restoreContext: 
    LOAD_REG  t1, nextTCBPtr        # t1 contains the value of nextTCBPtr i.e. nextTCBPtr (address of the next TCB )                
    LOAD_REG  sp, 0( t1 )        # load sp from nextTCB
    
    LOAD_REG t0,  PC_STACK_OFFSET ( sp )
    csrw mepc, t0
 
    LOAD_REG  t0, MSTATUS_STACK_OFFSET ( sp )
    csrw mstatus, t0                        

    LOAD_REG x1,  X1_STACK_OFFSET  ( sp )
    LOAD_REG x5,  X5_STACK_OFFSET  ( sp )
    LOAD_REG x6,  X6_STACK_OFFSET  ( sp )
    LOAD_REG x7,  X7_STACK_OFFSET  ( sp )
    LOAD_REG x8,  X8_STACK_OFFSET  ( sp )
    LOAD_REG x9,  X9_STACK_OFFSET  ( sp )
    LOAD_REG x10, X10_STACK_OFFSET ( sp )
    LOAD_REG x11, X11_STACK_OFFSET ( sp )
    LOAD_REG x12, X12_STACK_OFFSET ( sp )
    LOAD_REG x13, X13_STACK_OFFSET ( sp )
    LOAD_REG x14, X14_STACK_OFFSET ( sp )
    LOAD_REG x15, X15_STACK_OFFSET ( sp )
    LOAD_REG x16, X16_STACK_OFFSET ( sp )
    LOAD_REG x17, X17_STACK_OFFSET ( sp )
    LOAD_REG x18, X18_STACK_OFFSET ( sp )
    LOAD_REG x19, X19_STACK_OFFSET ( sp )
    LOAD_REG x20, X20_STACK_OFFSET ( sp )
    LOAD_REG x21, X21_STACK_OFFSET ( sp )
    LOAD_REG x22, X22_STACK_OFFSET ( sp )
    LOAD_REG x23, X23_STACK_OFFSET ( sp )
    LOAD_REG x24, X24_STACK_OFFSET ( sp )
    LOAD_REG x25, X25_STACK_OFFSET ( sp )
    LOAD_REG x26, X26_STACK_OFFSET ( sp )
    LOAD_REG x27, X27_STACK_OFFSET ( sp )
    LOAD_REG x28, X28_STACK_OFFSET ( sp )
    LOAD_REG x29, X29_STACK_OFFSET ( sp )
    LOAD_REG x30, X30_STACK_OFFSET ( sp )
    LOAD_REG x31, X31_STACK_OFFSET ( sp )
    
    addi sp, sp, CONTEXT_SIZE
    
    ret


/*******************************************************************************
*Function Name: initialiseStack
*Syntax : OsTask_stackType initialiseStack( OsTask_stackType stackTop , OsTask_EntryType entry)
*Parameter (In): stackTop    -pointer to stack top.
*                entry       -pointer to task entry
*Parameter (Out): none
*Parameter (In/Out): none
*Return : pointer to top of context .
*Description: initialize stack context .
*             store entry into stack , to ensures that the task code is being executed from the first statement.
*             setup and store mstatus into stack .
*Remark: stackTop passed in a0    , entry passed in a1 .
*********************************************************************************/
initialiseStack:
    csrr t0, mstatus                    /* copy mstatus register into t0. */
    andi t0, t0, ~0x8                   /* Disable interrupts */
	
	/* Next 3 instructions to Set MPIE(bit 7) and MPP(bits 11,12) bits in mstatus value. */
	/*the MPIE(Machine Previous Interrupt Enable) and  MPP(Machine Previous Privilge mode) in mstatus. */
	/* MPIE =1 -> enable interrupts after return from this exception , MPP=11 -> return to machine mode */
    addi t1, x0, 0x188                  /* Generate the value 0x188  , can not generate 0x1880 at one because immediate field is only 12 bit (3 hexa digits) */	
    slli t1, t1, 4                      /* 0x1880 <- (0x188<<4)  */
    or t0, t0, t1                       /* Set MPIE and MPP bits in mstatus value. */

    addi a0, a0, -CONTEXT_SIZE      /* space for Pc ,msatus ,x1 , x5-x31*/
    STORE_REG t0, MSTATUS_STACK_OFFSET(a0)                   /*store  mstatus onto the stack. */

    STORE_REG a1, PC_STACK_OFFSET(a0)                   /* store Entry of Task onto the stack. */
    ret



